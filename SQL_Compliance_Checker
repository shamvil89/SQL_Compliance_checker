################################################################################# 
## SQL Service Status Report in HTML using Powershell
## Created by Shamvil Hasan Kazmi
## Date : 19 Sept 2019 
## Version : 1.0 
## Below code will generate an HTML output which will give the status of all SQl service in the HTML format.The script you have create the
## folder "test" in C Drive or give the path in the last line of code where you want to generate the file.
#################################################################################

#enter SQL server instance Details
$hostname = Read-Host -Prompt 'Input your server name'
$serverinstance = Read-Host -Prompt 'Input the instance name'
#code creates connection string
$servername = $hostname+'\'+$serverinstance
#CSS Declaration

$Style = "<style>
TABLE{
border-width: 1px;
border-style: solid;
border-color: black;
border-collapse: collapse;
align:center;
margin-left:auto;
margin-right:auto;
}
TH{
border-width: 1px;
bgcolor=#FF0000;
padding: 3px;
border-style: solid;
border-color: black;
}
TD{
border-width: 1px;
padding: 3px;
border-style: solid;
border-color: black;
}
h1{
text-shadow: 1px 1px 1px #000,3px 3px 5px blue;
text-align: center;
font-style: calibri;
font-family: Calibri;
}
h2{
font-style: calibri;
font-family: Calibri;
}
h3{
font-style: calibri;
font-family: Calibri;
}
h4{
font-style: calibri;
font-family: Calibri;
}
</style>"

#fragment 1 - check if specific users accounts/groups are missing and if individual accounts are present. Good practive is individual accounts don't get access and they are added to AD groups
### make sure to change the domain and accounts as per your own environment. - I will include the line 62 in "Read me"
$frag1 = invoke-sqlcmd -ServerInstance $servername -Query "select name +' needs to be removed' as result from sys.syslogins where name like'domain\useraccount%' or name like 'domain\adm_useracount%'
if (select count(name) from sys.syslogins where name = 'domain\sqladmingroup') <> 1
select 'domain\sqladmingroup account needs to be added' as result
else
select ' domain\sqladmingroup is already added' as result
if (select count(name) from sys.syslogins where name = 'domain\monitoringaccount') <> 1
select 'domain\monitoringaccount account needs to be added' as result
else
select ' domain\monitoringaccount is already added' as result" | select result |ConvertTo-Html -As LIST -Fragment -PreContent '<h2>Logins that need to be added or removed</h2>'|Out-String

#fragment 2 - check if database files are stored in C drive. (They shouldn't be stored in C drive or a drive where OS is installed. but my code is not yet intelligent to tell if any other drive have OS installed. Assuming all OS is installed on C drive, this code creates report accordingly) 
$frag2 = invoke-sqlcmd -ServerInstance $servername -Query "if (select count(*) from sys.database_files where physical_name like 'C%') <> 0
select 'database files found in C drive' as comment, name as Datafiles from sys.database_files where physical_name like 'C%'
else select null as Datafiles, 'no db files in c drive found' as comment " | select Datafiles, comment |ConvertTo-Html -fragment -precontent '<h2>DB File locations </H2>' |Out-String

#fragment 3 - check if SQL server is running through LocalSystem. 
$frag3 = Get-WmiObject win32_service -ComputerName $hostname | Where-Object {$_.name -like “*SQL*” -and $_.Startname -like "*LocalSystem*"} |Select name, @{N='Service Account';E={$_.Startname}} , startmode, state |ConvertTo-Html -fragment -precontent '<h2>SQL Server with Service account as LocalSystem </H2>'|Out-String

#fragment 4 - checks if service accounts that are running SQL services don't have more than needed access on OS. Fragment 4 script was found over internet on a forum but unfortunatley I lost the soruce link, I will update the link if I find it in future.
$head = $style
$sas = Get-WmiObject win32_service -ComputerName $hostname |Where-Object {$_.name -like "*SQL*" -and $_.Description -like "*Provides storage, processing and controlled access of data, and rapid transaction processing*" -or $_.description -like "*Executes jobs, monitors SQL Server, fires alerts, and allows automation of some administrative tasks*"}|Select @{N='Service Account';E={$_.Startname}}
function get-rightsonwin {
# Fail script if we can't find SecEdit.exe
$SecEdit = Join-Path ([Environment]::GetFolderPath([Environment+SpecialFolder]::System)) "SecEdit.exe"
if ( -not (Test-Path $SecEdit) ) {
Write-Error "File not found - '$SecEdit'" -Category ObjectNotFound
exit
}
# LookupPrivilegeDisplayName Win32 API doesn't resolve logon right display
# names, so use this hashtable
$UserLogonRights = @{
"SeBatchLogonRight" = "Log on as a batch job"
"SeDenyBatchLogonRight" = "Deny log on as a batch job"
"SeDenyInteractiveLogonRight" = "Deny log on locally"
"SeDenyNetworkLogonRight" = "Deny access to this computer from the network"
"SeDenyRemoteInteractiveLogonRight" = "Deny log on through Remote Desktop Services"
"SeDenyServiceLogonRight" = "Deny log on as a service"
"SeInteractiveLogonRight" = "Allow log on locally"
"SeNetworkLogonRight" = "Access this computer from the network"
"SeRemoteInteractiveLogonRight" = "Allow log on through Remote Desktop Services"
"SeServiceLogonRight" = "Log on as a service"
}
# Create type to invoke LookupPrivilegeDisplayName Win32 API
$Win32APISignature = @'
[DllImport("advapi32.dll", SetLastError=true)]
public static extern bool LookupPrivilegeDisplayName(
string systemName,
string privilegeName,
System.Text.StringBuilder displayName,
ref uint cbDisplayName,
out uint languageId
);
'@
$AdvApi32 = Add-Type advapi32 $Win32APISignature -Namespace LookupPrivilegeDisplayName -PassThru
# Use LookupPrivilegeDisplayName Win32 API to get display name of privilege
# (except for user logon rights)
function Get-PrivilegeDisplayName {
param(
[String] $name
)
$displayNameSB = New-Object System.Text.StringBuilder 1024
$languageId = 0
$ok = $AdvApi32::LookupPrivilegeDisplayName($null, $name, $displayNameSB, [Ref] $displayNameSB.Capacity, [Ref] $languageId)
if ( $ok ) {
$displayNameSB.ToString()
}
else {
# Doesn't lookup logon rights, so use hashtable for that
if ( $UserLogonRights[$name] ) {
$UserLogonRights[$name]
}
else {
$name
}
}
}
# Outputs list of hashtables as a PSObject
function Out-Object {
param(
[System.Collections.Hashtable[]] $hashData
)
$order = @()
$result = @{}
$hashData | ForEach-Object {
$order += ($_.Keys -as [Array])[0]
$result += $_
}
New-Object PSObject -Property $result | Select-Object $order
}
# Translates a SID in the form *S-1-5-... to its account name;
function Get-AccountName {
param(
[String] $principal
)
if ( $principal[0] -eq "*" ) {
$sid = New-Object System.Security.Principal.SecurityIdentifier($principal.Substring(1))
$sid.Translate([Security.Principal.NTAccount])
}
else {
$principal
}
}
$TemplateFilename = Join-Path ([IO.Path]::GetTempPath()) ([IO.Path]::GetRandomFileName())
$LogFilename = Join-Path ([IO.Path]::GetTempPath()) ([IO.Path]::GetRandomFileName())
$StdOut = & $SecEdit /export /cfg $TemplateFilename /areas USER_RIGHTS /log $LogFilename
if ( $LASTEXITCODE -eq 0 ) {
Select-String '^(Se\S+) = (\S+)' $TemplateFilename | Foreach-Object {
$Privilege = $_.Matches[0].Groups[1].Value
$Principals = $_.Matches[0].Groups[2].Value -split ','
foreach ( $Principal in $Principals ) {
Out-Object `
  @{"Privilege" = $Privilege},
@{"PrivilegeName" = Get-PrivilegeDisplayName $Privilege},
@{"Principal" = Get-AccountName $Principal}
}
}
}
else {
$OFS = ""
Write-Error "$StdOut"
}
Remove-Item $TemplateFilename,$LogFilename -ErrorAction SilentlyContinue
#| Where-Object $Principal='Everyone'
}
function get-accountlists {

foreach ($sa in $sas) {
get-rightsonwin |select Privilege, PrivilegeName, Principal | Where-Object Principal -In $sa, 'Everyone'
}
}
$frag4 = get-accountlists |ConvertTo-Html -fragment -precontent '<h2>Ensure that below service accounts dont have below access </H2> <h3>
1. Log on as a service <br>
2. Log on as a batch job <br>
3. Replace a process-level token <br>
4. Bypass traverse checking <br>
5. Adjust memory quotas for a process</h3>' -PostContent "<h4>Please send aforementioned service account lists to Wintel team<h4>" |Out-String



#fragment 5 checks if the SQL server instance is running on default ports. It is best practive to not run your instances on default ports for security reasons.
$frag5 = Invoke-Sqlcmd -ServerInstance $servername -Query "DECLARE @portNo1 NVARCHAR(10)
EXEC xp_instance_regread
@rootkey = 'HKEY_LOCAL_MACHINE',
@key =
'Software\Microsoft\Microsoft SQL Server\MSSQLServer\SuperSocketNetLib\Tcp\IpAll',
@value_name = 'TcpPort',
@value = @portNo1 OUTPUT
-- Execute below script if SQL Server is configured with dynamic port number
DECLARE @portNo2 NVARCHAR(10)
EXEC xp_instance_regread
@rootkey = 'HKEY_LOCAL_MACHINE',
@key =
'Software\Microsoft\Microsoft SQL Server\MSSQLServer\SuperSocketNetLib\Tcp\IpAll',
@value_name = 'TcpDynamicPorts',
@value = @portNo2 OUTPUT
select convert(int, ISNULL(@portno1, 0) ) + ISNULL(convert(int, @portno2 ), 0) as port
" |select port |ConvertTo-Html -As LIST -Fragment -PreContent '<h2>SQL Server port</h2>'|Out-String
ConvertTo-HTML -head $head -PostContent $frag1,$frag2,$frag3, $frag4, $frag5 -PreContent “<h1>SQL Server Hardening Report</h1>” |Set-Content "C:\temp\test\Combined.html"
#output fle will be stored at ----> C:\temp\test\Combined.html
#End of the code
#the complaince checker is incomplete. there are tons of different things I want to add. I am just uploading this as a backup so in future I can resume my work regardless of where I am and what laptop I am using. :) 

 
